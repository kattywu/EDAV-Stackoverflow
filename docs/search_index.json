[["index.html", "Stack Overflow Tags Over Time Chapter 1 Introduction", " Stack Overflow Tags Over Time Emily Jennings-Dobbs and Yingyao Wu 2021-04-08 Chapter 1 Introduction As one of the biggest platforms for "],["data-sources.html", "Chapter 2 Data sources", " Chapter 2 Data sources The data chosen for this project was a sample of posts from stackoverflow.com which is an online platform where people post questions about code and receive answers from the general public. The StackOverflow database is massive containing over 100 GB of information so for our purposes we will be taking a small sample from each year we are interested in. The data is split into 7 files, one for every year from 2015 to 2021. Each was queried from https://data.stackexchange.com/stackoverflow/queries using the query select Id, AcceptedAnswerId, CreationDate, LastActivityDate, Tags, AnswerCount, CommentCount, ViewCount, Title from Posts where year(CreationDate) = YEAR and Tags IS NOT NULL Where YEAR is replaced by the desired year. Each file contains the first 50,000 tagged posts on https://stackoverflow.com/ for the given year and contains the following variables; Id: the unique Id given to each post AcceptedAnswerId: The unique Id associated with an accepted answer CreationDate: The date and time each post was created LastAcvtivityDate: The most recent date in which someone interacted with the post as of 3/25/21 Tags: A list of tags associated with the post separated by angle brackets (“&lt;&gt;”) AnswerCount: the number of answers each post has received CommentCount: the number of comments each post has received ViewCount: the number of views each post has received Title: Title of the post as specified by the author "],["data-transformation.html", "Chapter 3 Data transformation", " Chapter 3 Data transformation The initial step in cleaning the data was to combine the 7 data frames each containing 50,000 observations into one data frame containing 300,000 observations. Now, there are three things that need to changed in our data before it can be used for this analysis; The Tags need to be separated so that we can compare the usage of each tag individually We need to create a new variable to indicate whether or not there was an accepted answer based off of whether or not we were supplied an AcceptedAnswerId which we will refer to as AcceptAnswer Convert AcceptAnswer, Tags and Id into factors, and convert CreationDate and LastActivityDate into dates For our purposes we can omit title since we already have the post Id as a source of identification and we can omit AcceptedAnswerId because we only need the frequency of accepted answers which we have identified in AcceptAnswer. "],["missing-values.html", "Chapter 4 Missing values", " Chapter 4 Missing values Since our query did not include values without tags, the only missing values in our dataset are the missing values in AcceptedAnswerId as a result of the question not being answered. This problem is solved by the introduction of the indicator variable AcceptAnswer. Each post can only have one accepted answer so if we wish to determine if any other variables have an impact on the probability that a post will have an accepted answer we can use the proportion of posts that have answered posts to find our results. That being said, not every tag we have listed in each year will appear in all the other years. Sampling random tags from our dataset proves unhelpful due to relatively low frequency of use of many of the tags within our sample. df &lt;- df %&gt;% mutate(year = as.factor(year(CreationDate))) unique_tags &lt;- df %&gt;% group_by(year) %&gt;% summarize(n_tags = length(unique(Tags))) Since we are not interested in all 29085 unique tags, it will suffice to analyze the top 50 most used unique tags for each year. This leaves us with 72 unique tags with which to analyze trends. df_tab &lt;- sort(table(df %&gt;% filter(year==2015) %&gt;% dplyr::select(Tags)), decreasing = T) top_50_15 &lt;- names(df_tab[1:50]) df_tab &lt;- sort(table(df %&gt;% filter(year==2016) %&gt;% dplyr::select(Tags)), decreasing = T) top_50_16 &lt;- names(df_tab[1:50]) df_tab &lt;- sort(table(df %&gt;% filter(year==2017) %&gt;% dplyr::select(Tags)), decreasing = T) top_50_17 &lt;- names(df_tab[1:50]) df_tab &lt;- sort(table(df %&gt;% filter(year==2018) %&gt;% dplyr::select(Tags)), decreasing = T) top_50_18 &lt;- names(df_tab[1:50]) df_tab &lt;- sort(table(df %&gt;% filter(year==2019) %&gt;% dplyr::select(Tags)), decreasing = T) top_50_19 &lt;- names(df_tab[1:50]) df_tab &lt;- sort(table(df %&gt;% filter(year==2020) %&gt;% dplyr::select(Tags)), decreasing = T) top_50_20 &lt;- names(df_tab[1:50]) df_tab &lt;- sort(table(df %&gt;% filter(year==2021) %&gt;% dplyr::select(Tags)), decreasing = T) top_50_21 &lt;- names(df_tab[1:50]) top_full &lt;- unique(c(top_50_15, top_50_16, top_50_17, top_50_18, top_50_19, top_50_20, top_50_21)) rm(top_50_15) rm(top_50_16) rm(top_50_17) rm(top_50_18) rm(top_50_19) rm(top_50_20) rm(top_50_21) df1 &lt;- df[which((df$Tags %in% top_full)==TRUE),] library(gridExtra) set.seed(0) df_tab &lt;- sort(table(df$Tags), decreasing = T) sample_100 &lt;- sample(names(df_tab),100) newDF&lt;- df[which((df$Tags %in% sample_100)==TRUE),] grid.arrange( ggplot(newDF, aes(x=year, y=Tags, fill = ViewCount)) + geom_tile() + ggtitle(&quot;100 Random Tags&quot;), ggplot(df1, aes(x=year, y=Tags, fill = ViewCount)) + geom_tile() + ggtitle(&quot;50 Most Used Tags from Each Year &quot;), ncol=2) There is still have one tag (flutter), which isn’t used in all 7 years, however there should be enough data on the usage of these tags to compare them between the years. "],["results.html", "Chapter 5 Results 5.1 Correlation Between Variables 5.2 Relationship between Views and Answers 5.3 Usage over Time 5.4 Porportion of Usage 5.5 Rate of Change in Usage 5.6 Distribution of Interaction for 9 Programming Language Tags 5.7 Programming Languange Tags by Year", " Chapter 5 Results 5.1 Correlation Between Variables df1_count &lt;- df1 %&gt;% group_by(year, Tags) %&gt;% summarise(TotalViews = sum(ViewCount), TagCount = length(Tags), TotalComments = sum(CommentCount), AcceptedAnswers = sum(as.integer(as.character(AcceptAnswer))), TotalAnswers = sum(AnswerCount)) df1_count &lt;- df1_count %&gt;% group_by(year) %&gt;% mutate(TagRank = as.factor(rank(-TagCount, ties.method = &quot;first&quot;))) initial_rank &lt;- df1_count %&gt;% filter(year==2015) %&gt;% dplyr::select(Tags, TagRank) initial_rank &lt;- initial_rank %&gt;% rename(InitialRank = TagRank) initial_rank &lt;- initial_rank[,2:3] df1_count &lt;- left_join(df1_count, initial_rank) %&gt;% mutate(InitialRank = cut(as.numeric(InitialRank), breaks = seq(0,75,5), right = F)) p &lt;- ggpairs(df1_count %&gt;% dplyr::select(year, TotalViews,TagCount,TotalComments, AcceptedAnswers,TotalAnswers), columns = 2:6, aes(color=year), title = &quot;Interactions Between Continuous Variables&quot;) + theme_bw() + theme_update(text = element_text(size=15)) #scale colors for(i in 1:p$nrow) { for(j in 1:p$ncol){ p[i,j] &lt;- p[i,j] + scale_fill_manual(values=rev(c(&quot;#1B9E77&quot;, &quot;#D95F02&quot;, &quot;#7570B3&quot;, &quot;#E7298A&quot;, &quot;#66A61E&quot;, &quot;#E6AB02&quot;, &quot;#A6761D&quot;))) + scale_color_manual(values=rev(c(&quot;#1B9E77&quot;, &quot;#D95F02&quot;, &quot;#7570B3&quot;, &quot;#E7298A&quot;, &quot;#66A61E&quot;, &quot;#E6AB02&quot;, &quot;#A6761D&quot;))) } } p The variables TagCount, TotalComments, AcceptedAnswers, and TotalAnswers are all heavily correlated. To measure the success or popularity of each tag over time we are going to have to rely on one of these variables rather than a mixture of the four of them. Each of these four variables are also to a lesser extent positively correlated with the total views each tag receives. This may be due to minimal interactions to the post after the initial answers and comments come in. Logically it is unlikely that any one question has an infinite amount of answers, after a few reasonable answers are posted to a question there may be diminishing returns. The distribution for all of these variables are skewed right with long tails implying that we may have some outliers. grid.arrange( df1_count %&gt;% dplyr::select(year, TotalComments, AcceptedAnswers, TotalAnswers) %&gt;% group_by(year) %&gt;% summarise_all(sum) %&gt;% gather(&quot;Type&quot;,&quot;Value&quot;,-year) %&gt;% ggplot(aes(year, Value, fill = Type)) + geom_bar(position = &quot;dodge&quot;, stat = &quot;identity&quot;) + scale_fill_manual(&quot;legend&quot;, values = c(&quot;TotalComments&quot; = &quot;#0072B2&quot;, &quot;AcceptedAnswers&quot; = &quot;#D55E00&quot;, &quot;TotalAnswers&quot; = &quot;#CC79A7&quot;)) + theme_bw() + ggtitle(&quot;Sum of Variables by Year&quot;), df1_count %&gt;% dplyr::select(year, TotalViews) %&gt;% group_by(year) %&gt;% summarise_all(sum) %&gt;% gather(&quot;Type&quot;,&quot;Value&quot;,-year) %&gt;% ggplot(aes(year, Value, fill = Type)) + geom_bar(position = &quot;dodge&quot;, stat = &quot;identity&quot;) + scale_fill_manual(&quot;legend&quot;, values = c(&quot;TotalViews&quot; = &quot;#E69F00&quot;)) + theme_bw(),ncol=1) It appears that views accumulate over time, this measure will not give us an accurate depiction of a tags popularity in any given year but may be telling of which tag is most popular overall. Answers and comments accumulate over time to a lesser degree and are also likely to give a skewed definition of yearly popularity. The number of accepted answers for each tag are a little more stable over time, though there is a slightly smaller amount of accepted answers in the past year which may be related to the amount of time a question is up before being answered and then having that answer marked as accepted. 5.2 Relationship between Views and Answers df1_count %&gt;% group_by(Tags) %&gt;% mutate(totalviews = TotalViews/1000000) %&gt;% ggplot(aes(totalviews, TotalAnswers)) + geom_hex(bins = 30) + ggtitle(&quot;Total Views vs Total Answers&quot;) + xlab(&quot;Total Views (in millions)&quot;) + ylab(&quot;Total Answers&quot;) For tags with less than 2,500 answers, majority of the tags have similar total answers regardless of their total number of views, with two tags having high total views but average number of total answers, which might be outlier tags in this group. This may imply little to no correlation on the total answers and total views, so a tag having high views does not necessarily guarantee it will receive answers in proportional to its views. For tags that have answers in between 2,500 and 5,000 total answers, as the total number of views per tag increases, the total number of answers tend to increase as well. This suggests that the more views a tag in this group has, the more answers it is likely to receive. For tags that have more than 5,000 answers, the amount of views vary from the lowest to the greatest (10 million), suggesting little to no correlation between the number of views a tag in this group has and number of answers it has received. Some tags with less than 1 million views received more than 5000 answers, while some other tags in this group have more than 10 million views but received about the same amount of answers. 5.3 Usage over Time ggplot(df1_count, aes(x = year, stratum = TagRank, alluvium = Tags, fill = InitialRank, label = Tags)) + scale_fill_manual(values = rev(c(&quot;#6D5BAE&quot;, &quot;#5F6EB5&quot;, &quot;#4F7EBA&quot;, &quot;#3F8DBD&quot;, &quot;#329BBE&quot;, &quot;#2FA7BE&quot;, &quot;#38B2BE&quot;, &quot;#49BCBC&quot;, &quot;#5DC6BB&quot;, &quot;#72CEB9&quot;, &quot;#87D5B8&quot;, &quot;#9BDCB8&quot;, &quot;#AEE1B9&quot;, &quot;#BFE5BA&quot;, &quot;#CEE8BB&quot;)))+ scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + geom_flow(stat = &quot;alluvium&quot;, lode.guidance = &quot;frontback&quot;, color = &quot;darkgray&quot;) + geom_stratum(width = 3/7) + geom_text(stat = &quot;alluvium&quot;, aes(label = after_stat(alluvium)), size=8) + theme(legend.position = &quot;bottom&quot;, axis.text = element_text(size = 15, face = &quot;bold&quot;)) + ggtitle(&quot;Frequency of Tags by Year&quot;) This alluvial plot reveals some pretty interesting information about the trends in the usage of different tags over time and confirms the theory that the frequency of usage for each tag is not constant. Some noteworthy trends here include: Java and Javascript remain in the top five most used tags every year. Python surpassed Javascript as the top rank in 2018 and has maintained this position. 2016 contains one less rank due to the fact that no instances of the tag Flutter were in our sample for that year. reactjs, node.js, pandas, and flutter have been consistently increasing in rank since 2015. Usage of angular seems to have peaked in 2018 and now appears to be on a steady decline. Usage of dart appears to have dipped a little in 2016 but has been consistently rising since. As python-3.x rose in usage, python-2.7 decreased in usage which is to be expected. Tags seems to increase or decrease in usage slowly over time rather than jump rapidly in usage, however there are a few larger than expected jumps in popularity such as angular between 2016 and 2017, and flutter between 2018 and 2019. usage of angular appears to replace usage of angularjs between 2016 and 2017,as such angularjs is the only tag that ranked in the top 15 in 2015 and bottom 5 in 2021. angularjs is the only Tag to drop more than 30 ranks within one year. 5.4 Porportion of Usage treemap(df1_count, index = c(&quot;year&quot;, &quot;Tags&quot;), vSize = &quot;TagCount&quot;, title = &quot;Frequency of Tags&quot;) treemap(df1_count, index = c(&quot;year&quot;, &quot;Tags&quot;), vSize = &quot;AcceptedAnswers&quot;, title = &quot;Frequency of Accepted Answers&quot; ) #nearly identical but with notable differences; python and javascript always have a large proportion These two treemaps while very similar, emphasize that the amount of accepted answers in 2021 (and 2020 to a lesser extent) is much smaller than would be expected from the overall number of tags recorded. Aside from that we see that the distribution of accepted answers for each tag and frequency of each tag is practically identical. These figures really draw attention to the large proportion of the usage of python, Javascript, and java. These three tags always maintain their position in the top 5 most used tags and are proportionally used more than twice as much as tags that are between the fifth and tenth most used. 5.5 Rate of Change in Usage year2015 &lt;- df1_count %&gt;% group_by(Tags) %&gt;% filter(year == 2020) %&gt;% mutate(diff2015 = TagCount) %&gt;% dplyr::select(Tags, diff2015, TagCount) year2020 &lt;- df1_count %&gt;% group_by(Tags) %&gt;% filter(year == 2015) %&gt;% mutate(diff2020 = TagCount) %&gt;% dplyr::select(Tags, diff2020, TagCount) increase &lt;- full_join(year2015, year2020, &quot;Tags&quot;) %&gt;% group_by(Tags) %&gt;% mutate(diff = diff2020 - diff2015) %&gt;% mutate(increased = ifelse(diff &gt; 0, 1, 0)) %&gt;% dplyr::select(Tags, increased) df1_count_sub &lt;- df1_count %&gt;% filter(year %in% c(2015,2020)) df1_count_sub &lt;- left_join(df1_count_sub, increase, &quot;Tags&quot;) highlight &lt;- filter(df1_count_sub, increased == 0) df1_count_sub %&gt;% ggplot(aes(TagCount, fct_reorder(Tags, TagCount))) + geom_point(aes(color = year), alpha = 0.3) + geom_line(aes(group = Tags), alpha = 0.3) + geom_line(data = highlight, aes(group = Tags)) + geom_point(data = highlight, aes(color = year)) + ggtitle(&#39;Tag Counts in 2015 vs 2020&#39;) + xlab(&#39;Tag Count&#39;) + ylab(&#39;&#39;) + theme_bw() Highlighted tags are the ones with an increase from 2015 to 2020. From year 2015 to 2020, we can see python has gained a substantially large amount of interest by users based on the number of tags, and it is the only tag that has an increase in the top 12 tags with the most tag counts. Over the past five years, it seems like python has become the most popular programming language users have interacted with on StackOverflow in comparing to other languages such as javascript, java, c#, c++, which all have a decrease in the tag counts. 5.6 Distribution of Interaction for 9 Programming Language Tags Consider tags that are types of programming languages, we are interested in learning their distributions and the amount of interactions they received in each summary category. Often, questions being asked are related to the specific type of programming language; by selecting and analyzing tags of programming languages, we will be able to see the trends and differences in these tags/topics. languages &lt;- c(&quot;c&quot;,&quot;c#&quot;,&quot;c++&quot;,&quot;dart&quot;,&quot;java&quot;,&quot;javascript&quot;,&quot;sql&quot;,&quot;swift&quot;,&quot;python&quot;) grid.arrange( df1_count %&gt;% filter(Tags %in% languages) %&gt;% ggplot(aes(TotalComments, fct_reorder(Tags, TotalComments), fill = Tags)) + #scale_fill_manual(values = c(&#39;#ffffd9&#39;,&#39;#edf8b1&#39;,&#39;#c7e9b4&#39;,&#39;#7fcdbb&#39;,&#39;#41b6c4&#39;,&#39;#1d91c0&#39;,&#39;#225ea8&#39;,&#39;#0c2c84&#39;,&quot;#5DC6BB&quot;)) + scale_fill_brewer(palette = &quot;Set3&quot;) + geom_density_ridges(alpha = 0.8) + ggtitle(&quot;Total Comments by Tag&quot;) + ylab(&quot;Programming Languages&quot;) + xlab(&quot;Total Comments&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;), df1_count %&gt;% filter(Tags %in% languages) %&gt;% mutate(totalviews = TotalViews/1000000) %&gt;% ggplot(aes(totalviews, fct_reorder(Tags, totalviews), fill = Tags)) + #scale_fill_manual(values = c(&#39;#ffffd9&#39;,&#39;#edf8b1&#39;,&#39;#c7e9b4&#39;,&#39;#7fcdbb&#39;,&#39;#41b6c4&#39;,&#39;#1d91c0&#39;,&#39;#225ea8&#39;,&#39;#0c2c84&#39;,&quot;#5DC6BB&quot;)) + scale_fill_brewer(palette = &quot;Set3&quot;) + geom_density_ridges(alpha = 0.8) + ggtitle(&quot;Total Views by Tag&quot;) + ylab(&quot;Programming Languages&quot;) + xlab(&quot;Total Views (in millions)&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;), df1_count %&gt;% filter(Tags %in% languages) %&gt;% ggplot(aes(TotalAnswers, fct_reorder(Tags, TotalAnswers), fill = Tags)) + #scale_fill_manual(values = c(&#39;#ffffd9&#39;,&#39;#edf8b1&#39;,&#39;#c7e9b4&#39;,&#39;#7fcdbb&#39;,&#39;#41b6c4&#39;,&#39;#1d91c0&#39;,&#39;#225ea8&#39;,&#39;#0c2c84&#39;,&quot;#5DC6BB&quot;)) + scale_fill_brewer(palette = &quot;Set3&quot;) + geom_density_ridges(alpha = 0.8) + ggtitle(&quot;Total Answers by Tag&quot;) + ylab(&quot;Programming Languages&quot;) + xlab(&quot;Total Answers&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;),ncol=3) Based on the above Ridgeline plots, javascript, python, java, and c# seem to have the greatest variation in total comments, total views, and total answers across all years. They all appear to have more than one mode (peak of usage) in all three categories, unlike the other five programming language tags which have only one peak, the variations in the distributions of these three tags suggest questions might not be uniquely grouped or clustered together. In other words, we cannot easily infer the most common amount of comments/views/answers given only any of these three tags. Also, taking into account that each group is represented by a unique color, we can observe that java, c#, and dart have the same rank across each of the total comments/views/answers category, while the other tags are ranked differently based on the category For example, the rank of dart has remained consistent across three categories and is the programming language tag that has the lowest usage, i.e. the tag with the least user interactions in StackOverflow. 5.7 Programming Languange Tags by Year df1_count %&gt;% filter(Tags %in% languages) %&gt;% ggplot(aes(TotalAnswers, color = year, fill = year)) + geom_density(alpha = 0.2) + scale_color_manual(values = rev(c(&quot;#6D5BAE&quot;, &quot;#5F6EB5&quot;, &quot;#4F7EBA&quot;, &quot;#3F8DBD&quot;, &quot;#329BBE&quot;, &quot;#2FA7BE&quot;, &quot;#38B2BE&quot;))) + #scale_fill_brewer(palette = &quot;Dark2&quot;) + ggtitle(&quot;Total Answers by Year&quot;) + xlab(&quot;Total Answers&quot;) As shown in the histograms Sum of Variables by Year in section 1, tags in year 2021 has the least amount of usage in all of the total views, comments, answers, and accepted answers categories. However, if we take a closer look at the programming language tags as defined in the previous section, we will notice from the above density plots that around 6750 total answers there exists a local maximum for year 2021, which means year 2021 actually receives a decent amount of total answers for number of answers around 6000, despite it being the year with the least user interactions so far. So those 9 programming language tags have comparatively similar total answers in year 2021 as the previous years for high amount of total answers, or even to a greater extent if scaled proportional to the duration of the posts. "],["interactive-component.html", "Chapter 6 Interactive component 6.1 Parallel Coordinates Plot", " Chapter 6 Interactive component 6.1 Parallel Coordinates Plot Key: - Click axis label to change color, drag axis label to reorder - Click and drag to select multiple entries - Press “Keep” to remove all unselected entries from plot - Press “Remove” to remove selected entries from plot - Press “Reset” to remove all changes made from “keep” and “Exclude” - Hover over entry in grid below plot to highlight entry Code for plot adapted from Parallel Coordinates Examples Keep Remove Reset "],["conclusion.html", "Chapter 7 Conclusion", " Chapter 7 Conclusion "]]
